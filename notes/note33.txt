Paper name: 
Synthesizing Programs That Expose Performance Bottlenecks (CGO'18)


Research problem:
How to synthesize test programs that expose performance bottlenecks in a given method under test.

Insight:
The basic idea is to repeatedly mutate a program that uses the method to systematically increase the amount of work done by the method. 


Contributions:
Our first key contribution is to formulate the problem of finding a sequence of mutations that yields a bottleneck- exposing program as a combinatorial search problem.
Our second key contribution is to design PerfSyn as a general framework that can expose different kinds of performance bottlenecks.


Approach overview:

PerfSyn searches for bottlenecks in the method under test mut starting from an initial program p0. The program p0 is generated by PerfSyn and it contains the minimal number of statements required to execute mut without a crash. To search for a bottleneck PerfSyn modifies p0, e.g., by inserting method calls or by modifying the values passed to the calls. The approach identifies a program as bottleneck-exposing based on a configurable performance oracle.
The key challenge in exposing bottlenecks by automatically synthesizing programs is the large space of possible programs. This paper address this challenge based on feedback obtained from executing programs. Starting from the initial program p0, PerfSyn represents the space of possible modifications as a tree, where p0 is the root, each node is another possible program, and edges represent code modifications that turn one program into another one. The approach explores the tree while gathering feedback about how effective specific mutations are at getting closer to a bottleneck-exposing program. The feedback depends on the performance oracle used to identify bottleneck-exposing programs. For example, an oracle aimed at exposing an unexpected complexity class steers the approach toward programs where the observed complexity diverges more and more from the expected complexity. Likewise, an oracle aimed at exposing performance differences between two implementations targets the approach toward programs with such differences.

