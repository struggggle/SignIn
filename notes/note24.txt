Paper name: 
Reducing Combinatorics in GUI Testing of Android Applications (ICSE'16)


Research problem:
How to generate tests in a combinatorial, yet scalable, fashion?


Insight:
The Android ADF constrains the life cycle of components comprising an app, the styles of communication among its software components, and the ways in which GUI widgets and other commonly needed functionalities can be accessed. The knowledge of these constraints along with the metadata associated with each app can be used to automate many software testing activities, specifically combinatorial testing of apps.



Contributions:
TrimDroid relies on program analysis to extract formal specifications. These specifications express the app’s behavior (i.e., control flow between the various app screens) as well as the GUI elements and their dependencies. The dependencies among the GUI elements comprising the app are used to reduce the number of combinations with the help of a solver. 



Approach overview:
Given an Android APK file, TrimDroid employs static analysis techniques that are informed by the rules and constraints imposed by the Android ADF to identify GUI widgets that interact with one another. Thus, the set of inter-acting widgets become candidates for t-way combinatorial testing. By avoiding the generation of tests for widgets that do not inter-act, TrimDroid is able to significantly reduce the number of tests. For identifying the interactions, TrimDroid statically analyzes the control- and data-flow dependencies among the widgets and actions available on an app. Finally, TrimDroid uses an efficient constraint solver to enumerate the test cases covering all possible combinations of GUI widgets and actions.


TrimDroid is comprised of four major components: Model Extraction, Dependency Extraction, Sequence Generation, and Test-Case Generation.

(1)Model Extraction produces two types of models by statically analyzing an Android app:
• InterfaceModel(IM) provides a representation of all the GUI inputs of an app, including the input widgets and events (actions) for each Activity. TrimDroid uses the IM to determine how a GUI screen can be exercised in order to generate the tests for it.
• Activity Transition Model (ATM) is a finite state machine representing the event-driven behavior of an Android app, including the relationships among its Activities and their event handlers (transitions). Since our research targets GUI testing, we only extract information that is related to Activities, not other Android components (e.g., Services).

(2)Dependency Extraction identifies GUI-induced dependencies among app elements using a combination of control- and data-flow analysis techniques. Dependency Extraction identifies three types of dependencies (a) when one GUI widget depends on the value of another widget, e.g., a drop-down menu is disabled, because a check-box is not selected, (b) when a GUI event handler depends on a widget value, e.g., a button handler method uses the selected value of a check-box, and (c) when an Activity depends on the widget values from a preceding Activity, e.g., the widget values from a preceding Activity are included in the payload of an Intent starting a new Activity.

(3)Sequence Generation synthesizes sequences of events that cover the paths in the ATM. Each path in the ATM represents a sequence of events in a possible use case.

(4)Test-Case Generation constructs system tests by performing three key steps. First, it traverses the sequences of events representing the paths produced by Sequence Generation. Second, for each step in a given sequence, it uses Alloy Analyzer to generate value combinations for different GUI widgets. To that end, Test-Case Generation utilizes (1) the sets of dependent widgets generated by Dependency Extraction and (2) the specification of each widget in the IM. Lastly, Test-Case Generation merges the value combinations to create tests that cover the entire sequence of events in each path of the ATM.