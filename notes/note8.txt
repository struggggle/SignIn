Paper name: 
DetReduce: Minimizing Android GUI Test Suites for Regression Testing (ICSE'18)


Research problem:
How to create a small regression test suite for an Android app from a large test suite generated by an automated Android GUI testing tool?


Insight:
if we can identify and remove some common forms of redundancies introduced by existing automated GUI testing tools, then we can drastically lower the time required to minimize a GUI test suite.


Contributions:

There are three kinds of redundancies that are common in these test suites: 
1) some test cases can be safely removed from a test suite without impacting code and screen coverage
2) within a test case, certain loops can be eliminated without decreasing coverage
3) many test cases share common subsequences of actions whose repeated execution can be avoided by combining fragments from different action sequences. 
Based on these observations, an algorithm was developed to remove these redundancies one-by-one while preserving the overall code and screen coverage of the test suite.


Approach overview:

A two-phase algorithm to remove redundancies from a GUI test suite. 
(1)The first phase removes redundant traces and redundant loops greedily. It first re- moves redundant traces by greedily selecting traces such that each selected trace contributes new coverage to the coverage of the set of already selected traces. The non-selected traces are then redundant and are removed from the test suite. It then removes redundant loops from each remaining trace. In order to remove redundant loops in a trace, the algorithm creates the set of all traces obtained from the trace by removing zero or more loops. It then selects a trace from the set that does not decrease cumulative coverage, lowers cost of the trace maximally, and is replayable. Such a trace replaces the original trace in the test suite.
(2)The second phase removes redundant trace fragments as much as possible. For that it constructs a new set of traces by combining fragments of the traces in the set computed by the first phase. When splicing trace fragments, we found it useful to limit the number of fragments in spliced trace to a small number (three in our case), because a trace composed of many fragments tends to be non-replayable in practice. Thus, the second phase of the algorithm first creates the set of candidate traces composed of a bounded number of trace fragments. It then constructs a new test suite by greedily selecting traces from the set of candidate traces.

In both phases, whenever the algorithm generates a new trace, it checks whether the trace is replayable or not by executing it a few times. This prevents the algorithm from adding a non-replayable trace to the resulting regression test suite. If the algorithm finds a trace to be non-replayable, it identifies and saves the shortest non-replayable prefix of the trace. In the future, if the algorithm finds that a new trace starts with one of these saved prefixes, then it can safely infer that the trace is non-replayable and discard it.




